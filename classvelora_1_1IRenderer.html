<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Velora: velora::IRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="handled-exception.ico"/></td>
  <td id="projectalign">
   <div id="projectname">Velora
   </div>
   <div id="projectbrief">Modular, cross-platform multithreaded C++ game engine</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvelora_1_1IRenderer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classvelora_1_1IRenderer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">velora::IRenderer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="render_8hpp_source.html">render.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for velora::IRenderer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvelora_1_1IRenderer.png" usemap="#velora::IRenderer_map" alt=""/>
  <map id="velora::IRenderer_map" name="velora::IRenderer_map">
<area href="classvelora_1_1type_1_1Interface.html" title="Interface class that defines the interface for the implementation object." alt="velora::type::Interface" shape="rect" coords="0,0,337,24"/>
<area href="classvelora_1_1type_1_1Dispatcher.html" alt="velora::type::Dispatcher&lt; IRenderer, RendererImplType &gt;" shape="rect" coords="0,112,337,136"/>
<area href="classvelora_1_1RendererDispatcher.html" alt="velora::RendererDispatcher&lt; RendererImplType &gt;" shape="rect" coords="0,168,337,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5169d85fdb07deab8283b117d8f373c5" id="r_a5169d85fdb07deab8283b117d8f373c5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a5169d85fdb07deab8283b117d8f373c5">~IRenderer</a> ()=default</td></tr>
<tr class="separator:a5169d85fdb07deab8283b117d8f373c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3776a51862cf7a56382f309fb6edc2" id="r_a6f3776a51862cf7a56382f309fb6edc2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a6f3776a51862cf7a56382f309fb6edc2">good</a> () const =0</td></tr>
<tr class="memdesc:a6f3776a51862cf7a56382f309fb6edc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if renderer is properly initialized.  <br /></td></tr>
<tr class="separator:a6f3776a51862cf7a56382f309fb6edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3662b76339d35eb93c4692dc7fab2774" id="r_a3662b76339d35eb93c4692dc7fab2774"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a3662b76339d35eb93c4692dc7fab2774">close</a> ()=0</td></tr>
<tr class="memdesc:a3662b76339d35eb93c4692dc7fab2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the renderer notifies process.  <br /></td></tr>
<tr class="separator:a3662b76339d35eb93c4692dc7fab2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecf236562822c51f3d84d7e7e68a66b" id="r_a4ecf236562822c51f3d84d7e7e68a66b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a4ecf236562822c51f3d84d7e7e68a66b">join</a> ()=0</td></tr>
<tr class="memdesc:a4ecf236562822c51f3d84d7e7e68a66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the renderer to finish rendering and close.  <br /></td></tr>
<tr class="separator:a4ecf236562822c51f3d84d7e7e68a66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1a418b47c82f06f97a6542a91cc34f" id="r_a2c1a418b47c82f06f97a6542a91cc34f"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a2c1a418b47c82f06f97a6542a91cc34f">clearScreen</a> (glm::vec4 color, std::optional&lt; std::size_t &gt; fbo=std::nullopt)=0</td></tr>
<tr class="memdesc:a2c1a418b47c82f06f97a6542a91cc34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the screen with a color.  <br /></td></tr>
<tr class="separator:a2c1a418b47c82f06f97a6542a91cc34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f2b9a9e237302644b439a8786b7f46" id="r_af4f2b9a9e237302644b439a8786b7f46"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#af4f2b9a9e237302644b439a8786b7f46">render</a> (std::size_t vertex_buffer, std::size_t shader, <a class="el" href="structvelora_1_1ShaderInputs.html">ShaderInputs</a> shader_inputs=<a class="el" href="structvelora_1_1ShaderInputs.html">ShaderInputs</a>{}, <a class="el" href="structvelora_1_1RenderOptions.html">RenderOptions</a> options=<a class="el" href="structvelora_1_1RenderOptions.html">RenderOptions</a>{}, std::optional&lt; std::size_t &gt; fbo=std::nullopt)=0</td></tr>
<tr class="memdesc:af4f2b9a9e237302644b439a8786b7f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a vertex buffer using a specified shader.  <br /></td></tr>
<tr class="separator:af4f2b9a9e237302644b439a8786b7f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842697b745d434ebff36bd0259076337" id="r_a842697b745d434ebff36bd0259076337"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a842697b745d434ebff36bd0259076337">present</a> ()=0</td></tr>
<tr class="memdesc:a842697b745d434ebff36bd0259076337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Present the rendered frame.  <br /></td></tr>
<tr class="separator:a842697b745d434ebff36bd0259076337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71fdc87cc5d30c14b519905ca05ae56" id="r_af71fdc87cc5d30c14b519905ca05ae56"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#af71fdc87cc5d30c14b519905ca05ae56">updateViewport</a> (<a class="el" href="classvelora_1_1Resolution.html">Resolution</a> resolution)=0</td></tr>
<tr class="memdesc:af71fdc87cc5d30c14b519905ca05ae56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the viewport.  <br /></td></tr>
<tr class="separator:af71fdc87cc5d30c14b519905ca05ae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd6c48a6cf5ef9c00796edcb268e739" id="r_afbd6c48a6cf5ef9c00796edcb268e739"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvelora_1_1Resolution.html">Resolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#afbd6c48a6cf5ef9c00796edcb268e739">getViewport</a> () const =0</td></tr>
<tr class="memdesc:afbd6c48a6cf5ef9c00796edcb268e739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport resolution.  <br /></td></tr>
<tr class="separator:afbd6c48a6cf5ef9c00796edcb268e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e5b44e15a5cd05ddc8d69a712680d3" id="r_ac2e5b44e15a5cd05ddc8d69a712680d3"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#ac2e5b44e15a5cd05ddc8d69a712680d3">enableVSync</a> ()=0</td></tr>
<tr class="memdesc:ac2e5b44e15a5cd05ddc8d69a712680d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable VSync.  <br /></td></tr>
<tr class="separator:ac2e5b44e15a5cd05ddc8d69a712680d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca0edbfa440af8781e41698db0236aa" id="r_a4ca0edbfa440af8781e41698db0236aa"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a4ca0edbfa440af8781e41698db0236aa">disableVSync</a> ()=0</td></tr>
<tr class="memdesc:a4ca0edbfa440af8781e41698db0236aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable VSync.  <br /></td></tr>
<tr class="separator:a4ca0edbfa440af8781e41698db0236aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae38ba48d3fc77418c5b8dd87466cff2" id="r_aae38ba48d3fc77418c5b8dd87466cff2"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#aae38ba48d3fc77418c5b8dd87466cff2">constructVertexBuffer</a> (std::string name, const <a class="el" href="structvelora_1_1Mesh.html">Mesh</a> &amp;mesh)=0</td></tr>
<tr class="memdesc:aae38ba48d3fc77418c5b8dd87466cff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vertex buffer object (VBO) for rendering a mesh.  <br /></td></tr>
<tr class="separator:aae38ba48d3fc77418c5b8dd87466cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de702d0c5ebaa3e3233d20337c8c740" id="r_a6de702d0c5ebaa3e3233d20337c8c740"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a6de702d0c5ebaa3e3233d20337c8c740">eraseVertexBuffer</a> (std::size_t id)=0</td></tr>
<tr class="memdesc:a6de702d0c5ebaa3e3233d20337c8c740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a vertex buffer object (VBO) by ID.  <br /></td></tr>
<tr class="separator:a6de702d0c5ebaa3e3233d20337c8c740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7bd71bdc9898abb57bf55a48bba109" id="r_a6a7bd71bdc9898abb57bf55a48bba109"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a6a7bd71bdc9898abb57bf55a48bba109">getVertexBuffer</a> (std::string name) const =0</td></tr>
<tr class="memdesc:a6a7bd71bdc9898abb57bf55a48bba109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of a vertex buffer object (VBO) by name.  <br /></td></tr>
<tr class="separator:a6a7bd71bdc9898abb57bf55a48bba109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0006289d9369fa19fdfe9007a414580f" id="r_a0006289d9369fa19fdfe9007a414580f"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a0006289d9369fa19fdfe9007a414580f">constructShader</a> (std::string name, std::vector&lt; std::string &gt; vertex_code)=0</td></tr>
<tr class="memdesc:a0006289d9369fa19fdfe9007a414580f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new shader object with the given name and vertex code.  <br /></td></tr>
<tr class="separator:a0006289d9369fa19fdfe9007a414580f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbef4212a4a7629c909de553dedac38" id="r_a8bbef4212a4a7629c909de553dedac38"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a8bbef4212a4a7629c909de553dedac38">constructShader</a> (std::string name, std::vector&lt; std::string &gt; vertex_code, std::vector&lt; std::string &gt; fragment_code)=0</td></tr>
<tr class="memdesc:a8bbef4212a4a7629c909de553dedac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new shader object with the given name and vertex and fragment code.  <br /></td></tr>
<tr class="separator:a8bbef4212a4a7629c909de553dedac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4cf61c7d4c49c7dea383b9a177bef3" id="r_acf4cf61c7d4c49c7dea383b9a177bef3"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#acf4cf61c7d4c49c7dea383b9a177bef3">eraseShader</a> (std::size_t id)=0</td></tr>
<tr class="memdesc:acf4cf61c7d4c49c7dea383b9a177bef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a shader object by ID.  <br /></td></tr>
<tr class="separator:acf4cf61c7d4c49c7dea383b9a177bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4fbe73969b24c80740f95142601c80" id="r_ada4fbe73969b24c80740f95142601c80"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#ada4fbe73969b24c80740f95142601c80">getShader</a> (std::string name) const =0</td></tr>
<tr class="memdesc:ada4fbe73969b24c80740f95142601c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of a shader object by name.  <br /></td></tr>
<tr class="separator:ada4fbe73969b24c80740f95142601c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d514bfeb03a9df0a7b914595512a66" id="r_a58d514bfeb03a9df0a7b914595512a66"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a58d514bfeb03a9df0a7b914595512a66">constructShaderStorageBuffer</a> (std::string name, unsigned int binding_point, const std::size_t size, const void *data)=0</td></tr>
<tr class="memdesc:a58d514bfeb03a9df0a7b914595512a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new shader storage buffer.  <br /></td></tr>
<tr class="separator:a58d514bfeb03a9df0a7b914595512a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aaf854caf08672f879ab54639ddc9f" id="r_a98aaf854caf08672f879ab54639ddc9f"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a98aaf854caf08672f879ab54639ddc9f">updateShaderStorageBuffer</a> (std::size_t id, const std::size_t size, const void *data)=0</td></tr>
<tr class="memdesc:a98aaf854caf08672f879ab54639ddc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a shader storage buffer.  <br /></td></tr>
<tr class="separator:a98aaf854caf08672f879ab54639ddc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5975fb1b8a07c453ffa7a9e106c2f85" id="r_af5975fb1b8a07c453ffa7a9e106c2f85"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#af5975fb1b8a07c453ffa7a9e106c2f85">eraseShaderStorageBuffer</a> (std::size_t id)=0</td></tr>
<tr class="memdesc:af5975fb1b8a07c453ffa7a9e106c2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a shader storage buffer.  <br /></td></tr>
<tr class="separator:af5975fb1b8a07c453ffa7a9e106c2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63871ee9cc1008cfd17172ab920430b8" id="r_a63871ee9cc1008cfd17172ab920430b8"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a63871ee9cc1008cfd17172ab920430b8">getShaderStorageBuffer</a> (std::string name) const =0</td></tr>
<tr class="memdesc:a63871ee9cc1008cfd17172ab920430b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a shader storage buffer by name.  <br /></td></tr>
<tr class="separator:a63871ee9cc1008cfd17172ab920430b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496489debd7b16016cc7055b722a35f" id="r_a7496489debd7b16016cc7055b722a35f"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a7496489debd7b16016cc7055b722a35f">constructFrameBufferObject</a> (std::string name, <a class="el" href="classvelora_1_1Resolution.html">Resolution</a> resolution, std::initializer_list&lt; <a class="el" href="structvelora_1_1FBOAttachment.html">FBOAttachment</a> &gt; attachments)=0</td></tr>
<tr class="memdesc:a7496489debd7b16016cc7055b722a35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Frame Buffer Object (FBO) object.  <br /></td></tr>
<tr class="separator:a7496489debd7b16016cc7055b722a35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b36183d76af9ec983b56e01b78896c" id="r_ac2b36183d76af9ec983b56e01b78896c"><td class="memItemLeft" align="right" valign="top">virtual asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#ac2b36183d76af9ec983b56e01b78896c">eraseFrameBufferObject</a> (std::size_t id)=0</td></tr>
<tr class="memdesc:ac2b36183d76af9ec983b56e01b78896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a Frame Buffer Object (FBO) object by ID.  <br /></td></tr>
<tr class="separator:ac2b36183d76af9ec983b56e01b78896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d505986b20e623c38bcc2a04e693827" id="r_a6d505986b20e623c38bcc2a04e693827"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a6d505986b20e623c38bcc2a04e693827">getFrameBufferObject</a> (std::string name) const =0</td></tr>
<tr class="memdesc:a6d505986b20e623c38bcc2a04e693827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of a Frame Buffer Object (FBO) object by name.  <br /></td></tr>
<tr class="separator:a6d505986b20e623c38bcc2a04e693827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a81adf6ba2723d5e697e7795ee79d8" id="r_a19a81adf6ba2723d5e697e7795ee79d8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a19a81adf6ba2723d5e697e7795ee79d8">getFrameBufferObjectTextures</a> (std::size_t id) const =0</td></tr>
<tr class="memdesc:a19a81adf6ba2723d5e697e7795ee79d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IDs of the textures attached to a Frame Buffer Object (FBO) object.  <br /></td></tr>
<tr class="separator:a19a81adf6ba2723d5e697e7795ee79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvelora_1_1type_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvelora_1_1type_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvelora_1_1type_1_1Interface.html">velora::type::Interface</a></td></tr>
<tr class="memitem:ae2599a0262192740ef9764f507358b6e inherit pub_methods_classvelora_1_1type_1_1Interface" id="r_ae2599a0262192740ef9764f507358b6e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Interface.html#ae2599a0262192740ef9764f507358b6e">~Interface</a> ()</td></tr>
<tr class="separator:ae2599a0262192740ef9764f507358b6e inherit pub_methods_classvelora_1_1type_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5169d85fdb07deab8283b117d8f373c5" name="a5169d85fdb07deab8283b117d8f373c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5169d85fdb07deab8283b117d8f373c5">&#9670;&#160;</a></span>~IRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual velora::IRenderer::~IRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c1a418b47c82f06f97a6542a91cc34f" name="a2c1a418b47c82f06f97a6542a91cc34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1a418b47c82f06f97a6542a91cc34f">&#9670;&#160;</a></span>clearScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::clearScreen </td>
          <td>(</td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>fbo</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the screen with a color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color to clear the screen with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#aedbfcc0493497b3f2a57e0a422f9ba6d">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a3662b76339d35eb93c4692dc7fab2774" name="a3662b76339d35eb93c4692dc7fab2774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3662b76339d35eb93c4692dc7fab2774">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the renderer notifies process. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#afa415517e00668448786e6b17a183f92">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a7496489debd7b16016cc7055b722a35f" name="a7496489debd7b16016cc7055b722a35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7496489debd7b16016cc7055b722a35f">&#9670;&#160;</a></span>constructFrameBufferObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; velora::IRenderer::constructFrameBufferObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvelora_1_1Resolution.html">Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structvelora_1_1FBOAttachment.html">FBOAttachment</a> &gt;&#160;</td>
          <td class="paramname"><em>attachments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new Frame Buffer Object (FBO) object. </p>
<p>This method is used to create a new Frame Buffer Object (FBO) which is a collection of attachments (textures and/or render buffers) that can be used as a target for rendering. The caller must provide a valid name for the FBO, a resolution, and a list of attachments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the FBO. </td></tr>
    <tr><td class="paramname">resolution</td><td>The resolution of the FBO. </td></tr>
    <tr><td class="paramname">attachments</td><td>A list of attachments for the FBO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An awaitable that resolves to the ID of the created FBO or an empty optional if the FBO could not be created. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#af86533fcc9e449555d543e67629c97a3">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a0006289d9369fa19fdfe9007a414580f" name="a0006289d9369fa19fdfe9007a414580f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006289d9369fa19fdfe9007a414580f">&#9670;&#160;</a></span>constructShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; velora::IRenderer::constructShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vertex_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new shader object with the given name and vertex code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader </td></tr>
    <tr><td class="paramname">vertex_code</td><td><a class="el" href="structvelora_1_1Vertex.html" title="Vertex.">Vertex</a> shader code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the newly created shader object, or std::nullopt if the shader could not be created </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a06e7174b5be633e058dc278d9ac49536">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a8bbef4212a4a7629c909de553dedac38" name="a8bbef4212a4a7629c909de553dedac38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbef4212a4a7629c909de553dedac38">&#9670;&#160;</a></span>constructShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; velora::IRenderer::constructShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vertex_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fragment_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new shader object with the given name and vertex and fragment code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader </td></tr>
    <tr><td class="paramname">vertex_code</td><td><a class="el" href="structvelora_1_1Vertex.html" title="Vertex.">Vertex</a> shader code </td></tr>
    <tr><td class="paramname">fragment_code</td><td>Fragment shader code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the newly created shader object, or std::nullopt if the shader could not be created </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a6b505c038a3bce60b7f7c390d0d48204">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a58d514bfeb03a9df0a7b914595512a66" name="a58d514bfeb03a9df0a7b914595512a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d514bfeb03a9df0a7b914595512a66">&#9670;&#160;</a></span>constructShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; velora::IRenderer::constructShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>binding_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new shader storage buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the shader storage buffer </td></tr>
    <tr><td class="paramname">binding_point</td><td>The binding point of the shader storage buffer </td></tr>
    <tr><td class="paramname">size</td><td>The size of the shader storage buffer in bytes </td></tr>
    <tr><td class="paramname">data</td><td>The data to initialize the shader storage buffer with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the shader storage buffer, or std::nullopt if an error occurred </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a400cf5c2053ba69ffd104186a4c37b50">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="aae38ba48d3fc77418c5b8dd87466cff2" name="aae38ba48d3fc77418c5b8dd87466cff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae38ba48d3fc77418c5b8dd87466cff2">&#9670;&#160;</a></span>constructVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; velora::IRenderer::constructVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvelora_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vertex buffer object (VBO) for rendering a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique name for the VBO </td></tr>
    <tr><td class="paramname">mesh</td><td>the mesh data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the VBO, or std::nullopt if failed</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called on the render thread strand. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a7c4616f17df54cd72c83d82300573e33">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a4ca0edbfa440af8781e41698db0236aa" name="a4ca0edbfa440af8781e41698db0236aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca0edbfa440af8781e41698db0236aa">&#9670;&#160;</a></span>disableVSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::disableVSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable VSync. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#ad9165bddf7acb23a0b869c591e1846db">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="ac2e5b44e15a5cd05ddc8d69a712680d3" name="ac2e5b44e15a5cd05ddc8d69a712680d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e5b44e15a5cd05ddc8d69a712680d3">&#9670;&#160;</a></span>enableVSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::enableVSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable VSync. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a0fda21f4f947631905b84a909d8468ce">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="ac2b36183d76af9ec983b56e01b78896c" name="ac2b36183d76af9ec983b56e01b78896c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b36183d76af9ec983b56e01b78896c">&#9670;&#160;</a></span>eraseFrameBufferObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; bool &gt; velora::IRenderer::eraseFrameBufferObject </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a Frame Buffer Object (FBO) object by ID. </p>
<p>This method is used to erase a Frame Buffer Object (FBO) object by its ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the FBO object to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An awaitable that resolves to <code>true</code> if the FBO object was successfully erased, or <code>false</code> if it could not be erased. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#ad326a7cdd4c3aab6ffa82c3ed8492171">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="acf4cf61c7d4c49c7dea383b9a177bef3" name="acf4cf61c7d4c49c7dea383b9a177bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4cf61c7d4c49c7dea383b9a177bef3">&#9670;&#160;</a></span>eraseShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; bool &gt; velora::IRenderer::eraseShader </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a shader object by ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the shader object to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the shader object was successfully erased, <code>false</code> otherwise </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a492f3b04920d6653faf006c148fb2de8">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="af5975fb1b8a07c453ffa7a9e106c2f85" name="af5975fb1b8a07c453ffa7a9e106c2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5975fb1b8a07c453ffa7a9e106c2f85">&#9670;&#160;</a></span>eraseShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; bool &gt; velora::IRenderer::eraseShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a shader storage buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the shader storage buffer to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the shader storage buffer was successfully erased, <code>false</code> otherwise </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a9a72ce5bfaf986b2b69e22ba77680e85">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a6de702d0c5ebaa3e3233d20337c8c740" name="a6de702d0c5ebaa3e3233d20337c8c740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de702d0c5ebaa3e3233d20337c8c740">&#9670;&#160;</a></span>eraseVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; bool &gt; velora::IRenderer::eraseVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a vertex buffer object (VBO) by ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the VBO to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the VBO was successfully erased, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called on the render thread strand. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a3e1a44fd9d9fadb1a9aad8fc4f17a371">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a6d505986b20e623c38bcc2a04e693827" name="a6d505986b20e623c38bcc2a04e693827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d505986b20e623c38bcc2a04e693827">&#9670;&#160;</a></span>getFrameBufferObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; std::size_t &gt; velora::IRenderer::getFrameBufferObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of a Frame Buffer Object (FBO) object by name. </p>
<p>This method is used to get the ID of a Frame Buffer Object (FBO) object by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the FBO object to get the ID of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional size_t containing the ID of the FBO object, or an empty optional if the FBO object could not be found. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#add27861db20cf1e37fd127dc9c2e7112">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a19a81adf6ba2723d5e697e7795ee79d8" name="a19a81adf6ba2723d5e697e7795ee79d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a81adf6ba2723d5e697e7795ee79d8">&#9670;&#160;</a></span>getFrameBufferObjectTextures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::size_t &gt; velora::IRenderer::getFrameBufferObjectTextures </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IDs of the textures attached to a Frame Buffer Object (FBO) object. </p>
<p>This method is used to get the IDs of the textures attached to a Frame Buffer Object (FBO) object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the FBO object to get the texture IDs of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of size_t containing the IDs of the textures attached to the FBO object. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#ae7665f31d6d05ddd8a3d0232f16a3a92">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="ada4fbe73969b24c80740f95142601c80" name="ada4fbe73969b24c80740f95142601c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4fbe73969b24c80740f95142601c80">&#9670;&#160;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; std::size_t &gt; velora::IRenderer::getShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of a shader object by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the shader object, or std::nullopt if not found </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a578708d4a9baaadb8b1834850d213605">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a63871ee9cc1008cfd17172ab920430b8" name="a63871ee9cc1008cfd17172ab920430b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63871ee9cc1008cfd17172ab920430b8">&#9670;&#160;</a></span>getShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; std::size_t &gt; velora::IRenderer::getShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a shader storage buffer by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the shader storage buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the shader storage buffer, or std::nullopt if not found </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#abb27d3028d334930fcdaf89fc605253b">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a6a7bd71bdc9898abb57bf55a48bba109" name="a6a7bd71bdc9898abb57bf55a48bba109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7bd71bdc9898abb57bf55a48bba109">&#9670;&#160;</a></span>getVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; std::size_t &gt; velora::IRenderer::getVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of a vertex buffer object (VBO) by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the VBO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the VBO, or std::nullopt if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called on the render thread strand. </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#ada88a636700f5ed7f3306bb06585950e">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="afbd6c48a6cf5ef9c00796edcb268e739" name="afbd6c48a6cf5ef9c00796edcb268e739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd6c48a6cf5ef9c00796edcb268e739">&#9670;&#160;</a></span>getViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvelora_1_1Resolution.html">Resolution</a> velora::IRenderer::getViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewport resolution. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classvelora_1_1Resolution.html">Resolution</a> <a class="el" href="classvelora_1_1Resolution.html">Resolution</a> of the viewport </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a9fd5caafdf0bc6efa69e7c822b7d0c3b">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a6f3776a51862cf7a56382f309fb6edc2" name="a6f3776a51862cf7a56382f309fb6edc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3776a51862cf7a56382f309fb6edc2">&#9670;&#160;</a></span>good()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool velora::IRenderer::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if renderer is properly initialized. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if renderer is properly initialized and can render, <code>false</code> if renderer is closed or not initialized </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a6a29e21337440bae34c1e9a225b74e50">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a4ecf236562822c51f3d84d7e7e68a66b" name="a4ecf236562822c51f3d84d7e7e68a66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecf236562822c51f3d84d7e7e68a66b">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void velora::IRenderer::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the renderer to finish rendering and close. </p>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#af0960aa75fdf948397d53982980123e7">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a842697b745d434ebff36bd0259076337" name="a842697b745d434ebff36bd0259076337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842697b745d434ebff36bd0259076337">&#9670;&#160;</a></span>present()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::present </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Present the rendered frame. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a98cf3246cbf6375b113474d4bad4d7cf">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="af4f2b9a9e237302644b439a8786b7f46" name="af4f2b9a9e237302644b439a8786b7f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f2b9a9e237302644b439a8786b7f46">&#9670;&#160;</a></span>render()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::render </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>vertex_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvelora_1_1ShaderInputs.html">ShaderInputs</a>&#160;</td>
          <td class="paramname"><em>shader_inputs</em> = <code><a class="el" href="structvelora_1_1ShaderInputs.html">ShaderInputs</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvelora_1_1RenderOptions.html">RenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structvelora_1_1RenderOptions.html">RenderOptions</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>fbo</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render a vertex buffer using a specified shader. </p>
<p>This function enables a frame buffer object (FBO) if provided, sets the viewport, and renders the specified vertex buffer with the given shader. It applies shader inputs, and supports rendering options such as wireframe mode and polygon offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_buffer</td><td>ID of the vertex buffer to render. </td></tr>
    <tr><td class="paramname">shader</td><td>ID of the shader to use for rendering. </td></tr>
    <tr><td class="paramname">shader_inputs</td><td>Inputs to be passed to the shader. </td></tr>
    <tr><td class="paramname">options</td><td>Options for rendering, including rendering mode and polygon offset. </td></tr>
    <tr><td class="paramname">fbo</td><td>Optional frame buffer object to render into. If not provided, rendering is done to the default framebuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a854f54224c6fc44a12ee05307c7c54d3">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="a98aaf854caf08672f879ab54639ddc9f" name="a98aaf854caf08672f879ab54639ddc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98aaf854caf08672f879ab54639ddc9f">&#9670;&#160;</a></span>updateShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; bool &gt; velora::IRenderer::updateShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a shader storage buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the shader storage buffer to update </td></tr>
    <tr><td class="paramname">size</td><td>The size of the shader storage buffer in bytes </td></tr>
    <tr><td class="paramname">data</td><td>The data to update the shader storage buffer with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the shader storage buffer was successfully updated, <code>false</code> otherwise </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#aaa63910db3a22597788a742ac5710feb">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<a id="af71fdc87cc5d30c14b519905ca05ae56" name="af71fdc87cc5d30c14b519905ca05ae56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71fdc87cc5d30c14b519905ca05ae56">&#9670;&#160;</a></span>updateViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asio::awaitable&lt; void &gt; velora::IRenderer::updateViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvelora_1_1Resolution.html">Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the viewport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td><a class="el" href="classvelora_1_1Resolution.html">Resolution</a> of the viewport </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implemented in <a class="el" href="classvelora_1_1RendererDispatcher.html#a568072ac21995fbc8472bf9cbeb519f4">velora::RendererDispatcher&lt; RendererImplType &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/render/include/<a class="el" href="render_8hpp_source.html">render.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevelora.html">velora</a></li><li class="navelem"><a class="el" href="classvelora_1_1IRenderer.html">IRenderer</a></li>
    <li class="footer">Generated on Thu May 15 2025 for Velora by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
