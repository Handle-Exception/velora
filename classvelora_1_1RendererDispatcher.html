<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Velora: velora::RendererDispatcher&lt; RendererImplType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="handled-exception.ico"/></td>
  <td id="projectalign">
   <div id="projectname">Velora
   </div>
   <div id="projectbrief">Modular, cross-platform multithreaded C++ game engine</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classvelora_1_1RendererDispatcher.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classvelora_1_1RendererDispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">velora::RendererDispatcher&lt; RendererImplType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="render_8hpp_source.html">render.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for velora::RendererDispatcher&lt; RendererImplType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvelora_1_1RendererDispatcher.png" usemap="#velora::RendererDispatcher_3C_20RendererImplType_20_3E_map" alt=""/>
  <map id="velora::RendererDispatcher_3C_20RendererImplType_20_3E_map" name="velora::RendererDispatcher_3C_20RendererImplType_20_3E_map">
<area href="classvelora_1_1type_1_1Dispatcher.html" alt="velora::type::Dispatcher&lt; IRenderer, RendererImplType &gt;" shape="rect" coords="0,112,337,136"/>
<area href="classvelora_1_1IRenderer.html" alt="velora::IRenderer" shape="rect" coords="0,56,337,80"/>
<area href="classvelora_1_1type_1_1Interface.html" title="Interface class that defines the interface for the implementation object." alt="velora::type::Interface" shape="rect" coords="0,0,337,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa7d7f57b87baf5340b350091acf2d4eb" id="r_aa7d7f57b87baf5340b350091acf2d4eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#aa7d7f57b87baf5340b350091acf2d4eb">dispatch</a> = <a class="el" href="classvelora_1_1type_1_1Dispatcher.html">type::Dispatcher</a>&lt; <a class="el" href="classvelora_1_1IRenderer.html">IRenderer</a>, RendererImplType &gt;</td></tr>
<tr class="separator:aa7d7f57b87baf5340b350091acf2d4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8c5e35c862779fcf218bd5f425dbb908" id="r_a8c5e35c862779fcf218bd5f425dbb908"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a8c5e35c862779fcf218bd5f425dbb908">RendererDispatcher</a> (RendererImplType &amp;&amp;obj)</td></tr>
<tr class="separator:a8c5e35c862779fcf218bd5f425dbb908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9e93e4968737786b4e99910378eb58" id="r_a4e9e93e4968737786b4e99910378eb58"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4e9e93e4968737786b4e99910378eb58"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a4e9e93e4968737786b4e99910378eb58">RendererDispatcher</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a4e9e93e4968737786b4e99910378eb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945d1645608d954d62723a73603eaaff" id="r_a945d1645608d954d62723a73603eaaff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a945d1645608d954d62723a73603eaaff">~RendererDispatcher</a> ()=default</td></tr>
<tr class="separator:a945d1645608d954d62723a73603eaaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a29e21337440bae34c1e9a225b74e50" id="r_a6a29e21337440bae34c1e9a225b74e50"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a6a29e21337440bae34c1e9a225b74e50">good</a> () const override</td></tr>
<tr class="memdesc:a6a29e21337440bae34c1e9a225b74e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if renderer is properly initialized.  <br /></td></tr>
<tr class="separator:a6a29e21337440bae34c1e9a225b74e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa415517e00668448786e6b17a183f92" id="r_afa415517e00668448786e6b17a183f92"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#afa415517e00668448786e6b17a183f92">close</a> () override</td></tr>
<tr class="memdesc:afa415517e00668448786e6b17a183f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the renderer notifies process.  <br /></td></tr>
<tr class="separator:afa415517e00668448786e6b17a183f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0960aa75fdf948397d53982980123e7" id="r_af0960aa75fdf948397d53982980123e7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#af0960aa75fdf948397d53982980123e7">join</a> () override</td></tr>
<tr class="memdesc:af0960aa75fdf948397d53982980123e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the renderer to finish rendering and close.  <br /></td></tr>
<tr class="separator:af0960aa75fdf948397d53982980123e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbfcc0493497b3f2a57e0a422f9ba6d" id="r_aedbfcc0493497b3f2a57e0a422f9ba6d"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#aedbfcc0493497b3f2a57e0a422f9ba6d">clearScreen</a> (glm::vec4 color, std::optional&lt; std::size_t &gt; fbo) override</td></tr>
<tr class="memdesc:aedbfcc0493497b3f2a57e0a422f9ba6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the screen with a color.  <br /></td></tr>
<tr class="separator:aedbfcc0493497b3f2a57e0a422f9ba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f54224c6fc44a12ee05307c7c54d3" id="r_a854f54224c6fc44a12ee05307c7c54d3"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a854f54224c6fc44a12ee05307c7c54d3">render</a> (std::size_t vertex_buffer, std::size_t shader, <a class="el" href="structvelora_1_1ShaderInputs.html">ShaderInputs</a> shader_inputs, <a class="el" href="structvelora_1_1RenderOptions.html">RenderOptions</a> options, std::optional&lt; std::size_t &gt; fbo) override</td></tr>
<tr class="memdesc:a854f54224c6fc44a12ee05307c7c54d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render a vertex buffer using a specified shader.  <br /></td></tr>
<tr class="separator:a854f54224c6fc44a12ee05307c7c54d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cf3246cbf6375b113474d4bad4d7cf" id="r_a98cf3246cbf6375b113474d4bad4d7cf"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a98cf3246cbf6375b113474d4bad4d7cf">present</a> () override</td></tr>
<tr class="memdesc:a98cf3246cbf6375b113474d4bad4d7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Present the rendered frame.  <br /></td></tr>
<tr class="separator:a98cf3246cbf6375b113474d4bad4d7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568072ac21995fbc8472bf9cbeb519f4" id="r_a568072ac21995fbc8472bf9cbeb519f4"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a568072ac21995fbc8472bf9cbeb519f4">updateViewport</a> (<a class="el" href="classvelora_1_1Resolution.html">Resolution</a> resolution) override</td></tr>
<tr class="memdesc:a568072ac21995fbc8472bf9cbeb519f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the viewport.  <br /></td></tr>
<tr class="separator:a568072ac21995fbc8472bf9cbeb519f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd5caafdf0bc6efa69e7c822b7d0c3b" id="r_a9fd5caafdf0bc6efa69e7c822b7d0c3b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classvelora_1_1Resolution.html">Resolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a9fd5caafdf0bc6efa69e7c822b7d0c3b">getViewport</a> () const override</td></tr>
<tr class="memdesc:a9fd5caafdf0bc6efa69e7c822b7d0c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport resolution.  <br /></td></tr>
<tr class="separator:a9fd5caafdf0bc6efa69e7c822b7d0c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fda21f4f947631905b84a909d8468ce" id="r_a0fda21f4f947631905b84a909d8468ce"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a0fda21f4f947631905b84a909d8468ce">enableVSync</a> () override</td></tr>
<tr class="memdesc:a0fda21f4f947631905b84a909d8468ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable VSync.  <br /></td></tr>
<tr class="separator:a0fda21f4f947631905b84a909d8468ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9165bddf7acb23a0b869c591e1846db" id="r_ad9165bddf7acb23a0b869c591e1846db"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#ad9165bddf7acb23a0b869c591e1846db">disableVSync</a> () override</td></tr>
<tr class="memdesc:ad9165bddf7acb23a0b869c591e1846db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable VSync.  <br /></td></tr>
<tr class="separator:ad9165bddf7acb23a0b869c591e1846db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4616f17df54cd72c83d82300573e33" id="r_a7c4616f17df54cd72c83d82300573e33"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a7c4616f17df54cd72c83d82300573e33">constructVertexBuffer</a> (std::string name, const <a class="el" href="structvelora_1_1Mesh.html">Mesh</a> &amp;mesh) override</td></tr>
<tr class="memdesc:a7c4616f17df54cd72c83d82300573e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vertex buffer object (VBO) for rendering a mesh.  <br /></td></tr>
<tr class="separator:a7c4616f17df54cd72c83d82300573e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1a44fd9d9fadb1a9aad8fc4f17a371" id="r_a3e1a44fd9d9fadb1a9aad8fc4f17a371"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a3e1a44fd9d9fadb1a9aad8fc4f17a371">eraseVertexBuffer</a> (std::size_t id) override</td></tr>
<tr class="memdesc:a3e1a44fd9d9fadb1a9aad8fc4f17a371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a vertex buffer object (VBO) by ID.  <br /></td></tr>
<tr class="separator:a3e1a44fd9d9fadb1a9aad8fc4f17a371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada88a636700f5ed7f3306bb06585950e" id="r_ada88a636700f5ed7f3306bb06585950e"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#ada88a636700f5ed7f3306bb06585950e">getVertexBuffer</a> (std::string name) const override</td></tr>
<tr class="memdesc:ada88a636700f5ed7f3306bb06585950e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of a vertex buffer object (VBO) by name.  <br /></td></tr>
<tr class="separator:ada88a636700f5ed7f3306bb06585950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7174b5be633e058dc278d9ac49536" id="r_a06e7174b5be633e058dc278d9ac49536"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a06e7174b5be633e058dc278d9ac49536">constructShader</a> (std::string name, std::vector&lt; std::string &gt; vertex_code) override</td></tr>
<tr class="memdesc:a06e7174b5be633e058dc278d9ac49536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new shader object with the given name and vertex code.  <br /></td></tr>
<tr class="separator:a06e7174b5be633e058dc278d9ac49536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b505c038a3bce60b7f7c390d0d48204" id="r_a6b505c038a3bce60b7f7c390d0d48204"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a6b505c038a3bce60b7f7c390d0d48204">constructShader</a> (std::string name, std::vector&lt; std::string &gt; vertex_code, std::vector&lt; std::string &gt; fragment_code) override</td></tr>
<tr class="memdesc:a6b505c038a3bce60b7f7c390d0d48204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new shader object with the given name and vertex and fragment code.  <br /></td></tr>
<tr class="separator:a6b505c038a3bce60b7f7c390d0d48204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492f3b04920d6653faf006c148fb2de8" id="r_a492f3b04920d6653faf006c148fb2de8"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a492f3b04920d6653faf006c148fb2de8">eraseShader</a> (std::size_t id) override</td></tr>
<tr class="memdesc:a492f3b04920d6653faf006c148fb2de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a shader object by ID.  <br /></td></tr>
<tr class="separator:a492f3b04920d6653faf006c148fb2de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578708d4a9baaadb8b1834850d213605" id="r_a578708d4a9baaadb8b1834850d213605"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a578708d4a9baaadb8b1834850d213605">getShader</a> (std::string name) const override</td></tr>
<tr class="memdesc:a578708d4a9baaadb8b1834850d213605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of a shader object by name.  <br /></td></tr>
<tr class="separator:a578708d4a9baaadb8b1834850d213605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400cf5c2053ba69ffd104186a4c37b50" id="r_a400cf5c2053ba69ffd104186a4c37b50"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a400cf5c2053ba69ffd104186a4c37b50">constructShaderStorageBuffer</a> (std::string name, unsigned int binding_point, const std::size_t size, const void *data) override</td></tr>
<tr class="memdesc:a400cf5c2053ba69ffd104186a4c37b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new shader storage buffer.  <br /></td></tr>
<tr class="separator:a400cf5c2053ba69ffd104186a4c37b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa63910db3a22597788a742ac5710feb" id="r_aaa63910db3a22597788a742ac5710feb"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#aaa63910db3a22597788a742ac5710feb">updateShaderStorageBuffer</a> (std::size_t id, const std::size_t size, const void *data) override</td></tr>
<tr class="memdesc:aaa63910db3a22597788a742ac5710feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a shader storage buffer.  <br /></td></tr>
<tr class="separator:aaa63910db3a22597788a742ac5710feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a72ce5bfaf986b2b69e22ba77680e85" id="r_a9a72ce5bfaf986b2b69e22ba77680e85"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#a9a72ce5bfaf986b2b69e22ba77680e85">eraseShaderStorageBuffer</a> (std::size_t id) override</td></tr>
<tr class="memdesc:a9a72ce5bfaf986b2b69e22ba77680e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a shader storage buffer.  <br /></td></tr>
<tr class="separator:a9a72ce5bfaf986b2b69e22ba77680e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27d3028d334930fcdaf89fc605253b" id="r_abb27d3028d334930fcdaf89fc605253b"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#abb27d3028d334930fcdaf89fc605253b">getShaderStorageBuffer</a> (std::string name) const override</td></tr>
<tr class="memdesc:abb27d3028d334930fcdaf89fc605253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a shader storage buffer by name.  <br /></td></tr>
<tr class="separator:abb27d3028d334930fcdaf89fc605253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86533fcc9e449555d543e67629c97a3" id="r_af86533fcc9e449555d543e67629c97a3"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#af86533fcc9e449555d543e67629c97a3">constructFrameBufferObject</a> (std::string name, <a class="el" href="classvelora_1_1Resolution.html">Resolution</a> resolution, std::initializer_list&lt; <a class="el" href="structvelora_1_1FBOAttachment.html">FBOAttachment</a> &gt; attachments) override</td></tr>
<tr class="memdesc:af86533fcc9e449555d543e67629c97a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Frame Buffer Object (FBO) object.  <br /></td></tr>
<tr class="separator:af86533fcc9e449555d543e67629c97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad326a7cdd4c3aab6ffa82c3ed8492171" id="r_ad326a7cdd4c3aab6ffa82c3ed8492171"><td class="memItemLeft" align="right" valign="top">asio::awaitable&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#ad326a7cdd4c3aab6ffa82c3ed8492171">eraseFrameBufferObject</a> (std::size_t id) override</td></tr>
<tr class="memdesc:ad326a7cdd4c3aab6ffa82c3ed8492171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a Frame Buffer Object (FBO) object by ID.  <br /></td></tr>
<tr class="separator:ad326a7cdd4c3aab6ffa82c3ed8492171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add27861db20cf1e37fd127dc9c2e7112" id="r_add27861db20cf1e37fd127dc9c2e7112"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#add27861db20cf1e37fd127dc9c2e7112">getFrameBufferObject</a> (std::string name) const override</td></tr>
<tr class="memdesc:add27861db20cf1e37fd127dc9c2e7112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of a Frame Buffer Object (FBO) object by name.  <br /></td></tr>
<tr class="separator:add27861db20cf1e37fd127dc9c2e7112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7665f31d6d05ddd8a3d0232f16a3a92" id="r_ae7665f31d6d05ddd8a3d0232f16a3a92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1RendererDispatcher.html#ae7665f31d6d05ddd8a3d0232f16a3a92">getFrameBufferObjectTextures</a> (std::size_t id) const override</td></tr>
<tr class="memdesc:ae7665f31d6d05ddd8a3d0232f16a3a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IDs of the textures attached to a Frame Buffer Object (FBO) object.  <br /></td></tr>
<tr class="separator:ae7665f31d6d05ddd8a3d0232f16a3a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvelora_1_1type_1_1Dispatcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvelora_1_1type_1_1Dispatcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvelora_1_1type_1_1Dispatcher.html">velora::type::Dispatcher&lt; IRenderer, RendererImplType &gt;</a></td></tr>
<tr class="memitem:a6cb59997d97665c9cec0e7df101f1e2b inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a6cb59997d97665c9cec0e7df101f1e2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a6cb59997d97665c9cec0e7df101f1e2b">Dispatcher</a> (const <a class="el" href="classvelora_1_1type_1_1Dispatcher.html">Dispatcher</a> &amp;other)=delete</td></tr>
<tr class="separator:a6cb59997d97665c9cec0e7df101f1e2b inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab306cc8fa382b654bac748e261be3888 inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_ab306cc8fa382b654bac748e261be3888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#ab306cc8fa382b654bac748e261be3888">Dispatcher</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab306cc8fa382b654bac748e261be3888 inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3c0fd93e2ab4b88ffa3c97f4a2c3c5 inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a1d3c0fd93e2ab4b88ffa3c97f4a2c3c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a1d3c0fd93e2ab4b88ffa3c97f4a2c3c5">Dispatcher</a> (RendererImplType &amp;&amp;impl)</td></tr>
<tr class="separator:a1d3c0fd93e2ab4b88ffa3c97f4a2c3c5 inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f6f1547d545f7836f8378b20005cb4 inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a27f6f1547d545f7836f8378b20005cb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a27f6f1547d545f7836f8378b20005cb4">Dispatcher</a> (<a class="el" href="classvelora_1_1type_1_1Dispatcher.html">Dispatcher</a> &amp;&amp;other)</td></tr>
<tr class="separator:a27f6f1547d545f7836f8378b20005cb4 inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c20460dc02c44e27d4e395f544e58e inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a61c20460dc02c44e27d4e395f544e58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html">Dispatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a61c20460dc02c44e27d4e395f544e58e">operator=</a> (const <a class="el" href="classvelora_1_1type_1_1Dispatcher.html">Dispatcher</a> &amp;other)=delete</td></tr>
<tr class="separator:a61c20460dc02c44e27d4e395f544e58e inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b140987f25eb4cc61ec82a242d7d944 inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a1b140987f25eb4cc61ec82a242d7d944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html">Dispatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a1b140987f25eb4cc61ec82a242d7d944">operator=</a> (<a class="el" href="classvelora_1_1type_1_1Dispatcher.html">Dispatcher</a> &amp;&amp;other)</td></tr>
<tr class="separator:a1b140987f25eb4cc61ec82a242d7d944 inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2225298af85a401720ba602a50e73144 inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a2225298af85a401720ba602a50e73144"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a2225298af85a401720ba602a50e73144">~Dispatcher</a> ()</td></tr>
<tr class="separator:a2225298af85a401720ba602a50e73144 inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa7c20cb5d9f7517a1fbe25b6bcfd11 inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_a4aa7c20cb5d9f7517a1fbe25b6bcfd11"><td class="memItemLeft" align="right" valign="top">constexpr RendererImplType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#a4aa7c20cb5d9f7517a1fbe25b6bcfd11">getImpl</a> ()</td></tr>
<tr class="separator:a4aa7c20cb5d9f7517a1fbe25b6bcfd11 inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5133ce8378ac802c71d3c78de386f4d inherit pub_methods_classvelora_1_1type_1_1Dispatcher" id="r_ad5133ce8378ac802c71d3c78de386f4d"><td class="memItemLeft" align="right" valign="top">constexpr const RendererImplType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Dispatcher.html#ad5133ce8378ac802c71d3c78de386f4d">getImpl</a> () const</td></tr>
<tr class="separator:ad5133ce8378ac802c71d3c78de386f4d inherit pub_methods_classvelora_1_1type_1_1Dispatcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvelora_1_1IRenderer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvelora_1_1IRenderer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvelora_1_1IRenderer.html">velora::IRenderer</a></td></tr>
<tr class="memitem:a5169d85fdb07deab8283b117d8f373c5 inherit pub_methods_classvelora_1_1IRenderer" id="r_a5169d85fdb07deab8283b117d8f373c5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1IRenderer.html#a5169d85fdb07deab8283b117d8f373c5">~IRenderer</a> ()=default</td></tr>
<tr class="separator:a5169d85fdb07deab8283b117d8f373c5 inherit pub_methods_classvelora_1_1IRenderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvelora_1_1type_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvelora_1_1type_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvelora_1_1type_1_1Interface.html">velora::type::Interface</a></td></tr>
<tr class="memitem:ae2599a0262192740ef9764f507358b6e inherit pub_methods_classvelora_1_1type_1_1Interface" id="r_ae2599a0262192740ef9764f507358b6e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvelora_1_1type_1_1Interface.html#ae2599a0262192740ef9764f507358b6e">~Interface</a> ()</td></tr>
<tr class="separator:ae2599a0262192740ef9764f507358b6e inherit pub_methods_classvelora_1_1type_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa7d7f57b87baf5340b350091acf2d4eb" name="aa7d7f57b87baf5340b350091acf2d4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d7f57b87baf5340b350091acf2d4eb">&#9670;&#160;</a></span>dispatch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::dispatch =  <a class="el" href="classvelora_1_1type_1_1Dispatcher.html">type::Dispatcher</a>&lt;<a class="el" href="classvelora_1_1IRenderer.html">IRenderer</a>, RendererImplType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8c5e35c862779fcf218bd5f425dbb908" name="a8c5e35c862779fcf218bd5f425dbb908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5e35c862779fcf218bd5f425dbb908">&#9670;&#160;</a></span>RendererDispatcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::RendererDispatcher </td>
          <td>(</td>
          <td class="paramtype">RendererImplType &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e9e93e4968737786b4e99910378eb58" name="a4e9e93e4968737786b4e99910378eb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9e93e4968737786b4e99910378eb58">&#9670;&#160;</a></span>RendererDispatcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::RendererDispatcher </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a945d1645608d954d62723a73603eaaff" name="a945d1645608d954d62723a73603eaaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945d1645608d954d62723a73603eaaff">&#9670;&#160;</a></span>~RendererDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::~<a class="el" href="classvelora_1_1RendererDispatcher.html">RendererDispatcher</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aedbfcc0493497b3f2a57e0a422f9ba6d" name="aedbfcc0493497b3f2a57e0a422f9ba6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbfcc0493497b3f2a57e0a422f9ba6d">&#9670;&#160;</a></span>clearScreen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::clearScreen </td>
          <td>(</td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>fbo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the screen with a color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Color to clear the screen with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a2c1a418b47c82f06f97a6542a91cc34f">velora::IRenderer</a>.</p>

</div>
</div>
<a id="afa415517e00668448786e6b17a183f92" name="afa415517e00668448786e6b17a183f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa415517e00668448786e6b17a183f92">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the renderer notifies process. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a3662b76339d35eb93c4692dc7fab2774">velora::IRenderer</a>.</p>

</div>
</div>
<a id="af86533fcc9e449555d543e67629c97a3" name="af86533fcc9e449555d543e67629c97a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86533fcc9e449555d543e67629c97a3">&#9670;&#160;</a></span>constructFrameBufferObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::constructFrameBufferObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvelora_1_1Resolution.html">Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structvelora_1_1FBOAttachment.html">FBOAttachment</a> &gt;&#160;</td>
          <td class="paramname"><em>attachments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new Frame Buffer Object (FBO) object. </p>
<p>This method is used to create a new Frame Buffer Object (FBO) which is a collection of attachments (textures and/or render buffers) that can be used as a target for rendering. The caller must provide a valid name for the FBO, a resolution, and a list of attachments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the FBO. </td></tr>
    <tr><td class="paramname">resolution</td><td>The resolution of the FBO. </td></tr>
    <tr><td class="paramname">attachments</td><td>A list of attachments for the FBO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An awaitable that resolves to the ID of the created FBO or an empty optional if the FBO could not be created. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a7496489debd7b16016cc7055b722a35f">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a06e7174b5be633e058dc278d9ac49536" name="a06e7174b5be633e058dc278d9ac49536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e7174b5be633e058dc278d9ac49536">&#9670;&#160;</a></span>constructShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::constructShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vertex_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new shader object with the given name and vertex code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader </td></tr>
    <tr><td class="paramname">vertex_code</td><td><a class="el" href="structvelora_1_1Vertex.html" title="Vertex.">Vertex</a> shader code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the newly created shader object, or std::nullopt if the shader could not be created </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a0006289d9369fa19fdfe9007a414580f">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a6b505c038a3bce60b7f7c390d0d48204" name="a6b505c038a3bce60b7f7c390d0d48204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b505c038a3bce60b7f7c390d0d48204">&#9670;&#160;</a></span>constructShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::constructShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vertex_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fragment_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new shader object with the given name and vertex and fragment code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader </td></tr>
    <tr><td class="paramname">vertex_code</td><td><a class="el" href="structvelora_1_1Vertex.html" title="Vertex.">Vertex</a> shader code </td></tr>
    <tr><td class="paramname">fragment_code</td><td>Fragment shader code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the newly created shader object, or std::nullopt if the shader could not be created </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a8bbef4212a4a7629c909de553dedac38">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a400cf5c2053ba69ffd104186a4c37b50" name="a400cf5c2053ba69ffd104186a4c37b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400cf5c2053ba69ffd104186a4c37b50">&#9670;&#160;</a></span>constructShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::constructShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>binding_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new shader storage buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the shader storage buffer </td></tr>
    <tr><td class="paramname">binding_point</td><td>The binding point of the shader storage buffer </td></tr>
    <tr><td class="paramname">size</td><td>The size of the shader storage buffer in bytes </td></tr>
    <tr><td class="paramname">data</td><td>The data to initialize the shader storage buffer with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the shader storage buffer, or std::nullopt if an error occurred </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a58d514bfeb03a9df0a7b914595512a66">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a7c4616f17df54cd72c83d82300573e33" name="a7c4616f17df54cd72c83d82300573e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4616f17df54cd72c83d82300573e33">&#9670;&#160;</a></span>constructVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; std::optional&lt; std::size_t &gt; &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::constructVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvelora_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vertex buffer object (VBO) for rendering a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a unique name for the VBO </td></tr>
    <tr><td class="paramname">mesh</td><td>the mesh data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the VBO, or std::nullopt if failed</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called on the render thread strand. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#aae38ba48d3fc77418c5b8dd87466cff2">velora::IRenderer</a>.</p>

</div>
</div>
<a id="ad9165bddf7acb23a0b869c591e1846db" name="ad9165bddf7acb23a0b869c591e1846db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9165bddf7acb23a0b869c591e1846db">&#9670;&#160;</a></span>disableVSync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::disableVSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable VSync. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a4ca0edbfa440af8781e41698db0236aa">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a0fda21f4f947631905b84a909d8468ce" name="a0fda21f4f947631905b84a909d8468ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fda21f4f947631905b84a909d8468ce">&#9670;&#160;</a></span>enableVSync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::enableVSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable VSync. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#ac2e5b44e15a5cd05ddc8d69a712680d3">velora::IRenderer</a>.</p>

</div>
</div>
<a id="ad326a7cdd4c3aab6ffa82c3ed8492171" name="ad326a7cdd4c3aab6ffa82c3ed8492171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad326a7cdd4c3aab6ffa82c3ed8492171">&#9670;&#160;</a></span>eraseFrameBufferObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; bool &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::eraseFrameBufferObject </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a Frame Buffer Object (FBO) object by ID. </p>
<p>This method is used to erase a Frame Buffer Object (FBO) object by its ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the FBO object to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An awaitable that resolves to <code>true</code> if the FBO object was successfully erased, or <code>false</code> if it could not be erased. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#ac2b36183d76af9ec983b56e01b78896c">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a492f3b04920d6653faf006c148fb2de8" name="a492f3b04920d6653faf006c148fb2de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492f3b04920d6653faf006c148fb2de8">&#9670;&#160;</a></span>eraseShader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; bool &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::eraseShader </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a shader object by ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the shader object to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the shader object was successfully erased, <code>false</code> otherwise </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#acf4cf61c7d4c49c7dea383b9a177bef3">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a9a72ce5bfaf986b2b69e22ba77680e85" name="a9a72ce5bfaf986b2b69e22ba77680e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a72ce5bfaf986b2b69e22ba77680e85">&#9670;&#160;</a></span>eraseShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; bool &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::eraseShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a shader storage buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the shader storage buffer to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the shader storage buffer was successfully erased, <code>false</code> otherwise </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#af5975fb1b8a07c453ffa7a9e106c2f85">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a3e1a44fd9d9fadb1a9aad8fc4f17a371" name="a3e1a44fd9d9fadb1a9aad8fc4f17a371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1a44fd9d9fadb1a9aad8fc4f17a371">&#9670;&#160;</a></span>eraseVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; bool &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::eraseVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a vertex buffer object (VBO) by ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the VBO to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the VBO was successfully erased, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called on the render thread strand. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a6de702d0c5ebaa3e3233d20337c8c740">velora::IRenderer</a>.</p>

</div>
</div>
<a id="add27861db20cf1e37fd127dc9c2e7112" name="add27861db20cf1e37fd127dc9c2e7112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add27861db20cf1e37fd127dc9c2e7112">&#9670;&#160;</a></span>getFrameBufferObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::size_t &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::getFrameBufferObject </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of a Frame Buffer Object (FBO) object by name. </p>
<p>This method is used to get the ID of a Frame Buffer Object (FBO) object by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the FBO object to get the ID of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional size_t containing the ID of the FBO object, or an empty optional if the FBO object could not be found. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a6d505986b20e623c38bcc2a04e693827">velora::IRenderer</a>.</p>

</div>
</div>
<a id="ae7665f31d6d05ddd8a3d0232f16a3a92" name="ae7665f31d6d05ddd8a3d0232f16a3a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7665f31d6d05ddd8a3d0232f16a3a92">&#9670;&#160;</a></span>getFrameBufferObjectTextures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::getFrameBufferObjectTextures </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IDs of the textures attached to a Frame Buffer Object (FBO) object. </p>
<p>This method is used to get the IDs of the textures attached to a Frame Buffer Object (FBO) object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the FBO object to get the texture IDs of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of size_t containing the IDs of the textures attached to the FBO object. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a19a81adf6ba2723d5e697e7795ee79d8">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a578708d4a9baaadb8b1834850d213605" name="a578708d4a9baaadb8b1834850d213605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578708d4a9baaadb8b1834850d213605">&#9670;&#160;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; std::size_t &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::getShader </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of a shader object by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the shader object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the shader object, or std::nullopt if not found </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#ada4fbe73969b24c80740f95142601c80">velora::IRenderer</a>.</p>

</div>
</div>
<a id="abb27d3028d334930fcdaf89fc605253b" name="abb27d3028d334930fcdaf89fc605253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb27d3028d334930fcdaf89fc605253b">&#9670;&#160;</a></span>getShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; std::size_t &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::getShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the id of a shader storage buffer by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the shader storage buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the shader storage buffer, or std::nullopt if not found </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a63871ee9cc1008cfd17172ab920430b8">velora::IRenderer</a>.</p>

</div>
</div>
<a id="ada88a636700f5ed7f3306bb06585950e" name="ada88a636700f5ed7f3306bb06585950e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada88a636700f5ed7f3306bb06585950e">&#9670;&#160;</a></span>getVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; std::size_t &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::getVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of a vertex buffer object (VBO) by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the VBO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the VBO, or std::nullopt if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called on the render thread strand. </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a6a7bd71bdc9898abb57bf55a48bba109">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a9fd5caafdf0bc6efa69e7c822b7d0c3b" name="a9fd5caafdf0bc6efa69e7c822b7d0c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd5caafdf0bc6efa69e7c822b7d0c3b">&#9670;&#160;</a></span>getViewport()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classvelora_1_1Resolution.html">Resolution</a> <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::getViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewport resolution. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classvelora_1_1Resolution.html">Resolution</a> <a class="el" href="classvelora_1_1Resolution.html">Resolution</a> of the viewport </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#afbd6c48a6cf5ef9c00796edcb268e739">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a6a29e21337440bae34c1e9a225b74e50" name="a6a29e21337440bae34c1e9a225b74e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a29e21337440bae34c1e9a225b74e50">&#9670;&#160;</a></span>good()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if renderer is properly initialized. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if renderer is properly initialized and can render, <code>false</code> if renderer is closed or not initialized </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a6f3776a51862cf7a56382f309fb6edc2">velora::IRenderer</a>.</p>

</div>
</div>
<a id="af0960aa75fdf948397d53982980123e7" name="af0960aa75fdf948397d53982980123e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0960aa75fdf948397d53982980123e7">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the renderer to finish rendering and close. </p>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a4ecf236562822c51f3d84d7e7e68a66b">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a98cf3246cbf6375b113474d4bad4d7cf" name="a98cf3246cbf6375b113474d4bad4d7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cf3246cbf6375b113474d4bad4d7cf">&#9670;&#160;</a></span>present()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::present </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Present the rendered frame. </p>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a842697b745d434ebff36bd0259076337">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a854f54224c6fc44a12ee05307c7c54d3" name="a854f54224c6fc44a12ee05307c7c54d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854f54224c6fc44a12ee05307c7c54d3">&#9670;&#160;</a></span>render()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::render </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>vertex_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvelora_1_1ShaderInputs.html">ShaderInputs</a>&#160;</td>
          <td class="paramname"><em>shader_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvelora_1_1RenderOptions.html">RenderOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>fbo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Render a vertex buffer using a specified shader. </p>
<p>This function enables a frame buffer object (FBO) if provided, sets the viewport, and renders the specified vertex buffer with the given shader. It applies shader inputs, and supports rendering options such as wireframe mode and polygon offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_buffer</td><td>ID of the vertex buffer to render. </td></tr>
    <tr><td class="paramname">shader</td><td>ID of the shader to use for rendering. </td></tr>
    <tr><td class="paramname">shader_inputs</td><td>Inputs to be passed to the shader. </td></tr>
    <tr><td class="paramname">options</td><td>Options for rendering, including rendering mode and polygon offset. </td></tr>
    <tr><td class="paramname">fbo</td><td>Optional frame buffer object to render into. If not provided, rendering is done to the default framebuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#af4f2b9a9e237302644b439a8786b7f46">velora::IRenderer</a>.</p>

</div>
</div>
<a id="aaa63910db3a22597788a742ac5710feb" name="aaa63910db3a22597788a742ac5710feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa63910db3a22597788a742ac5710feb">&#9670;&#160;</a></span>updateShaderStorageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; bool &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::updateShaderStorageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a shader storage buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the shader storage buffer to update </td></tr>
    <tr><td class="paramname">size</td><td>The size of the shader storage buffer in bytes </td></tr>
    <tr><td class="paramname">data</td><td>The data to update the shader storage buffer with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the shader storage buffer was successfully updated, <code>false</code> otherwise </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#a98aaf854caf08672f879ab54639ddc9f">velora::IRenderer</a>.</p>

</div>
</div>
<a id="a568072ac21995fbc8472bf9cbeb519f4" name="a568072ac21995fbc8472bf9cbeb519f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568072ac21995fbc8472bf9cbeb519f4">&#9670;&#160;</a></span>updateViewport()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RendererImplType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::awaitable&lt; void &gt; <a class="el" href="classvelora_1_1RendererDispatcher.html">velora::RendererDispatcher</a>&lt; RendererImplType &gt;::updateViewport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvelora_1_1Resolution.html">Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the viewport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td><a class="el" href="classvelora_1_1Resolution.html">Resolution</a> of the viewport </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>asio::awaitable&lt;void&gt; </dd></dl>

<p>Implements <a class="el" href="classvelora_1_1IRenderer.html#af71fdc87cc5d30c14b519905ca05ae56">velora::IRenderer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/render/include/<a class="el" href="render_8hpp_source.html">render.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevelora.html">velora</a></li><li class="navelem"><a class="el" href="classvelora_1_1RendererDispatcher.html">RendererDispatcher</a></li>
    <li class="footer">Generated on Thu May 15 2025 for Velora by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
